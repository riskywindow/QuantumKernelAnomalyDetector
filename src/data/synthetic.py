"""Synthetic advantage dataset generation.

Constructs datasets where quantum kernel advantage is theoretically guaranteed.
Labels are determined by the quantum kernel's own structure: the fidelity
between each data point's quantum state and a random reference state.

This creates a controlled experiment complementing real-world fraud results.

References:
    - Liu et al. (2021): "A rigorous and robust quantum speed-up in
      supervised machine learning"
"""

from __future__ import annotations

import numpy as np
from qiskit.quantum_info import Statevector

from src.kernels.feature_maps.base import BaseFeatureMap


def generate_quantum_advantage_dataset(
    feature_map: BaseFeatureMap,
    n_samples: int = 500,
    n_features: int = 5,
    noise_rate: float = 0.05,
    seed: int = 42,
) -> tuple[np.ndarray, np.ndarray]:
    """Generate a dataset with provable quantum kernel advantage.

    Labels are generated by the quantum kernel's own structure:
    1. Sample random data points in [0, 2*pi]^n_features
    2. Pick a random reference point x_ref
    3. Label each point: y_i = 1 if K(x_ref, x_i) > median, else 0
    4. Add label noise at rate noise_rate

    The quantum kernel naturally captures the similarity to the reference
    state, while classical kernels operating on raw features cannot
    efficiently reproduce this labeling function.

    Args:
        feature_map: Quantum feature map to use for labeling.
            Must have n_qubits == n_features.
        n_samples: Number of samples to generate.
        n_features: Dimensionality (must match feature_map.n_qubits).
        noise_rate: Fraction of labels to flip randomly (0 to 1).
        seed: Random seed for reproducibility.

    Returns:
        X: Data of shape (n_samples, n_features) in [0, 2*pi].
        y: Binary labels of shape (n_samples,).

    Raises:
        ValueError: If n_features doesn't match feature_map.n_qubits.
    """
    if n_features != feature_map.n_qubits:
        raise ValueError(
            f"n_features ({n_features}) must match "
            f"feature_map.n_qubits ({feature_map.n_qubits})"
        )

    rng = np.random.default_rng(seed)

    # Generate random data in [0, 2*pi]
    X = rng.uniform(0, 2 * np.pi, size=(n_samples, n_features))

    # Pick a random reference point
    x_ref = rng.uniform(0, 2 * np.pi, size=(n_features,))

    # Build reference quantum state
    ref_circuit = feature_map.build_circuit(x_ref)
    sv_ref = Statevector.from_instruction(ref_circuit)

    # Compute fidelity for each data point: K(x_ref, x_i)
    fidelities = np.zeros(n_samples)
    for i in range(n_samples):
        circuit_i = feature_map.build_circuit(X[i])
        sv_i = Statevector.from_instruction(circuit_i)
        # Fidelity = |<psi_ref|psi_i>|^2
        fidelities[i] = abs(sv_ref.inner(sv_i)) ** 2

    # Set threshold at median for balanced labels
    threshold = np.median(fidelities)
    y = (fidelities > threshold).astype(np.float64)

    # Add label noise
    if noise_rate > 0:
        n_flip = int(noise_rate * n_samples)
        flip_indices = rng.choice(n_samples, size=n_flip, replace=False)
        y[flip_indices] = 1.0 - y[flip_indices]

    return X, y


def generate_quantum_advantage_split(
    feature_map: BaseFeatureMap,
    n_train: int = 300,
    n_test: int = 200,
    n_features: int = 5,
    noise_rate: float = 0.05,
    seed: int = 42,
) -> tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """Generate a train/test split for the quantum advantage dataset.

    Args:
        feature_map: Quantum feature map to use for labeling.
        n_train: Number of training samples.
        n_test: Number of test samples.
        n_features: Dimensionality (must match feature_map.n_qubits).
        noise_rate: Fraction of labels to flip randomly.
        seed: Random seed for reproducibility.

    Returns:
        X_train: Training data of shape (n_train, n_features).
        X_test: Test data of shape (n_test, n_features).
        y_train: Training labels of shape (n_train,).
        y_test: Test labels of shape (n_test,).
    """
    n_total = n_train + n_test
    X, y = generate_quantum_advantage_dataset(
        feature_map=feature_map,
        n_samples=n_total,
        n_features=n_features,
        noise_rate=noise_rate,
        seed=seed,
    )

    X_train = X[:n_train]
    X_test = X[n_train:]
    y_train = y[:n_train]
    y_test = y[n_train:]

    return X_train, X_test, y_train, y_test
